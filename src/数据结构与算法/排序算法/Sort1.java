package 数据结构与算法.排序算法;

/**
 * 1. 一种算法，。
 *      排序分类：
 *                  1.内部排序 ： 将数据加载到内存中进行排序
 *                              直接插入排序，希尔排序、简单选择排序、堆排序、冒泡排序、快速排序、归并排序、基数排序
 *                  2.外部排序法 ：数据量过大，无法加载到内存中，需要借助外部排序
 *
 * 2。 衡量一个算法执行时间（算法的时间复杂度）
 *      2.1 事后统计法 ：缺点 ， 遇到海量数据的时候，没有办法统计  ， (硬件设备可能不同)
 *      2.2 事前估算法 ： 通过算法的时间复杂度
 *
 *    时间频度：一个算法耗时与算法中语句的执行次数成正比，  哪个算法中语句执行次数多，花费时间也越多
 *              一个算法中的语句执行次数称为语句品读或时间频度T（n）
 *              T(N) = 2n
 *              T(n) =2n +10   统计时间频度时其中常数项可以忽略
 *
 *              T（n) = 2n^2 +3n +10 对比2n^2 , 可以忽略低次项 3n+10
 *
 *              2n^2 和 3n^2  ,可以忽略系数
 *
 *    时间复杂度：
 *              T(N) = O(f(n)) ,f(n) 为时间复杂度
 *              T(N) 不同，但是时间复杂度可以相同，例如：T(n) =n² + 2n  和 T（n）=n² 都是 O（n²）
 *
 *    常见的时间复杂度：常数阶O（1） < 对数阶o（log2n） <线性阶O（n） <线性对数阶o（nlog2n） <平方阶o（n²） < 立方阶o（n³）
 *
 */
public class Sort1 {

    //时间频度 n+1
    public void show(){
        int a = 0 ;
        int num =100;
        for (int i =0; i <num;i++){
            a+=i;
        }
    }

    //时间频度 1
    public void show1(){
        int a = 0 ;
        int num =100;
       a =(1+num)*num/2;
    }


    //常数阶O（1）  ，  代码执行次数不随着变量而变化
    public void O1(){
        int a = 0 ;
        int num =100;
        a =(1+num)*num/2;
    }

    //对数阶O（log2n）  ，  代码执行次数随着变量而变化
    public void log2n(){
        int a = 1 ;
        while (a<1024){
            a = a * 2;  //2 的 a 次方
        }
    }

    //线性阶O（n）  ，  代码执行次数随着变量而变化
    public void n(){
        int a = 1 ;
        for (;;){

       }
    }

    //线性对数阶O（nlog2n）  ，  代码执行次数随着变量而变化
    public void nlog2n(){
        for (int i =0;i < 100 ;i++) {  //n
            int a = 1 ;
            while (a<1024){
                a = a * 2;  //2 的 a 次方
            }
        }
    }

}
